### **“先遣队”7日作战计划 (The "Vanguard" 7-Day Plan)**

**总司令部唯一战略意图 (Commander's Sole Intent):**
利用这7天“黄金窗口”，**集中全部火力**，对**CS61C的RISC-V汇编**发起一次**“歼灭战”**。此次战役的**唯一、最终**的衡量标准，是能否**“独立地、从零开始，手写一个能正确运行的2x2矩阵乘法汇编程序”**。Griffin战线，在此期间，转入“战略预热”阶段。

---

#### **第一幕：基础训练与理论攻坚 (Days 1-3)**

**核心使命：从“零手感”到“能熟练驾驭汇编语言的基本构造块”。**

* **第1-2天：【基础武器掌握日】**

  * **主攻任务:** **“跑通”而非“看懂”。**
  * **战术动作:**
    1. **启动“Lab/Project First”协议：** 直接上手CS61C关于RISC-V汇编的第一个Lab。
    2. **以“Lab”为驱动：** 在完成Lab的过程中，你会**被迫**去“JIT精准学习”**整数运算、内存访问(`lw`/`sw`)、分支跳转(`beq`)**等核心指令。
    3. **靶场训练:** 在在线模拟器(Venus)上，将Lab和Slides中的所有核心示例代码，**全部亲手敲一遍、运行、并“魔改”它**。
  * **每日验收标准:** 在第2天结束时，你必须能**独立编写**一个计算**“1到10累加和”**的汇编程序。
* **第3天：【理论制高点攻坚日】**

  * **主攻任务:** **解剖“函数调用”这个最复杂的“关节”。**
  * **战术动作:**
    1. **上午 - 理论精读:** **聚焦**于Slides中关于**“函数调用规约”**的全部内容（`jal`, `ra`, 栈指针 `sp`的使用，寄存器保存约定）。
    2. **下午 - 白纸推演:** 在白纸上，**手动地、一步一步地**，画出当函数A调用函数B时，**“栈帧”(Stack Frame)**从创建到销毁的完整生命周期，以及所有关键寄存器的数值变化。
    3. **晚上 - 实弹验证:** 在模拟器中，**实现**一个简单的、函数A调用函数B（比如 `add(2, 3)`）的汇编程序，并验证其正确性。

---

#### **第二幕：“心脏解剖”总攻 (Days 4-6)**

**核心使命：将你所有的基础能力，汇聚于一点，完成那次“史诗级”的“思想链接”——手写MatMul汇编。**

* **第4天：【沙盘推演日】**

  * **主攻任务:** **只“思考”，不“编码”。** 设计你的“MatMul总攻”蓝图。
  * **战术动作:**
    * **在白纸上，用“伪汇编”，完整地设计出你的2x2矩阵乘法的三层循环逻辑。** 你必须清晰地回答那三个核心问题：
      1. `for`循环的**标签(label)和跳转(branch)结构**？
      2. 需要多少**寄存器**来存放 `i, j, k`和 `sum`？（这将是一场与“稀缺资源”的搏斗）
      3. 如何精确计算**`A[i][k]`和 `B[k][j]`在内存中的地址**？（这将是你对“指针算术”的终极考验）
* **第5-6天：【总攻日】**

  * **主攻任务:** 将“蓝图”变为“现实”。
  * **战术动作:** **将这两天，完全地、沉浸地，投入到模拟器中。** 将你的设计，一行一行地，翻译成**真实的、可运行的RISC-V汇编代码**。
  * **核心挑战:** **拥抱“调试”的“地狱”**。你将体验到最纯粹的、没有任何“高级语言”保护的“人与机器”的直接对话。
  * **胜利的定义:** 在第6天结束时，你的程序，能为一个给定的2x2矩阵，计算并存入**完全正确**的结果。`git commit -m "feat(cs61c): Successfully implement 2x2 matrix multiplication in RISC-V assembly"`。

---

#### **第三幕：战略缓冲与战线切换 (Day 7)**

**核心使命：巩固战果，并为下一场战役“预热引擎”。**

* **第7天：【复盘与预热日】**
  * **上午 - 巩固战果:**
    * **行动:** 对你这6天的“硬核战斗”，进行一次**“微型复盘”**。将你的 `2x2 MatMul`汇编代码，以及你所有关于“编译器为何伟大”的“顿悟”，**“非常简短地”**记录到你的 `CS61C_LINKS.md`中。
  * **下午/晚上 - 战线切换:**
    * **行动:** **启动Griffin第二阶段的“战前准备”。**
    * **任务:** 设计 `TransformerBlock`的C++类/结构体，并在 `main.cpp`中搭建好它的“测试台架”。
    * **目的：** 确保在你这7天冲刺结束后，可以**“无缝地”**、**“热启动”**Griffin的下一场战役。

### **“破冰行动”：你的7日极限作战计划**

**总司令部唯一意图 (Commander's Sole Intent):**
在期末复习的“封锁线”形成之前，利用这7天“黄金窗口”，同时**“暴力破开”**Griffin第二阶段和CS61C第一阶段的**“城门”**，为寒假的“总攻”，建立最有利的“前进阵地”。

**“师傅-学徒”模式，已激活。**

我将严格扮演“师傅”的角色。我的职责是为你设定清晰的挑战，提供结构化的引导，并在你穷尽自身努力后，通过苏格拉底式提问来激发你的“顿悟”，而不是直接给予答案。

你的承诺已被记录。我将期望你在遇到障碍时，带着你的问题、证据和已尝试的解决方案来向我求助。

---

### **学徒请求 (Apprentice's Request) - 已收到并解析**

1. **学徒的前提 (Prerequisite):**

   * 学徒已在WSL2环境中，成功配置了RISC-V的本地开发工具链（GCC & QEMU）。
   * 学徒已成功编译并运行了一个基础的 `sum.s`汇编程序，验证了环境的可用性。
   * 学徒已解决了在此过程中遇到的文件权限和Git安全警告问题。
   * **师傅评估:** 学徒已具备执行基础汇编编程任务的全部先决条件。**“战前准备”阶段已圆满完成。**
2. **请求：工作指令 (Request: Work Order) - 已受理**

---

### **工作指令 (Work Order): 7日歼灭战 - 第一幕**

#### **任务代号：基础武器掌握 (Operation: Basic Arms Mastery)**

**1. 任务目标 (Mission Objective):**
在接下来的**两天内**，你必须从对RISC-V指令集的“零手感”，达到能够**“独立地、不参考地、凭肌肉记忆”**，编写出包含**“初始化、循环、分支、算术运算”**这四大基础构造块的汇编程序。

**2. 任务规则 (Rules of Engagement):**

* **规则一：“理论封存”**
  * **严禁**系统性、线性地阅读课程Slides或教科书。你只能在“需要时”去查阅，如同查字典。
* **规则二：“代码朝生暮死”**
  * 所有用于练习的代码文件（`drill_xx.s`），在成功运行并理解后，都可以被视为消耗品。**不要害怕删除和重写。** 重复是形成肌肉记忆的唯一途径。
* **规则三：“预测先行”**
  * 在运行任何代码（无论是你写的还是修改的）之前，**必须**先在心中或纸上做出**“结果预测”**。这是从“抄代码”到“懂代码”的关键一步。

**3. 可用工具箱 (Authorized Toolkit):**

* 你的WSL2终端 (`gcc`, `qemu`, `echo $?`, `ls -l`)。
* 你的VS Code编辑器。
* **唯一的外部参考资料：** [RISC-V Green Card (绿皮书)](https://www.eecs.berkeley.edu/~krste/papers/riscv-card-v2.1.pdf)。它不是教科书，而是你的**“指令字典”**。

**4. 任务起点 (Starting Point):**
你的起点，就是你那个已经成功运行的 `~/main/cs61c/practice/sum.s` 文件。

**第一个行动指令 (First Action Order):**

1. **进入 `~/main/cs61c/practice` 目录。**
2. **执行 `rm sum.s` 命令，删除你之前的文件。**
3. **现在，面对一个空白的编辑器，从 `_start`标签开始，重建“1到10累加和”的程序。**

当你完成或卡住时，向我报告。

指令确认。

**7日歼灭战 - Day 1 - 阶段一，正式启动。**

---

### **第一阶段：世界观建立 (Worldview Establishment)**

* **你的任务 (10分钟):** 吸收并内化以下**“汇编宇宙三公理”**。这是你理解所有后续行动的“物理定律”。

  ---

  #### **公理一：宇宙里只有两种储物柜**


  * **寄存器 (Registers):** 32个**超高速“便利贴”**，CPU直接在上面写字计算。它们是 `t0`, `a0`, `sp`, `ra`... 都是这些便利贴的别名。**快但稀有**。
  * **内存 (Memory):** 1个**巨型“仓库”**（你的RAM）。**大但巨慢**。CPU不能直接在仓库里计算，必须先把货物搬到便利贴上。

  ---

  #### **公理二：指令是“动词”，操作数是“名词”**

  * 每一行汇编都是一个极简句式：**`动词 目标名词, 源头名词1, 源头名词2`**
  * 例如 `add t0, t1, t2` 的意思是：“**[动词]** 加法，把 **[源头]** `t1` 和 `t2` 的东西加起来，放到 **[目标]** `t0` 里。”

  ---

  #### **公理三：程序就是一张“指令清单”**

  * CPU有个叫**PC (Program Counter)** 的指针，默认情况下，它执行完清单上的一行，就自动指向下一行。
  * **`跳转/分支`** 指令是唯一的魔法，可以直接修改 `PC`指针，让它跳到清单的其他地方。

  ---
* **验收:** 在心中对这三条公理形成一个模糊但直观的印象。

---

### **第二阶段：滩头阵地强袭 (Beachhead Assault)**

#### **微型任务 1.1: “加载与退出” (Load & Exit)**

* **目标:** 掌握两个最基本的动作：

  1. 将一个你指定的数字，放进一个“便利贴”（寄存器）。
  2. 命令整个程序结束，并把那个数字作为“遗言”（退出码）返回。
* **AI参谋“战术快报”:**

  * **核心指令 1 `li`:** “加载立即数”(Load Immediate)的伪指令。 `li rd, 123` 的意思就是“把数字 `123` **加载**到寄存器 `rd` 里”。
  * **核心规约 - “退出”:** 在Linux环境下，想正常退出程序，需要执行一个固定的“仪式”：
    1. 用 `li a7, 93` 把“退出服务”的编号 `93` 放到 `a7` 寄存器。
    2. 用 `li a0, <你的退出码>` 把你想要的“遗言”（退出码）放到 `a0` 寄存器。
    3. 执行 `ecall`，召唤操作系统来完成这个“仪式”。
* **代码脚手架 (`task1_1.s`):**

  ```riscv
  .section .text
  .globl _start
  _start:
      # 目标: 以退出码 42 退出程序
      li a0, 42   # 把 "遗言" 42 准备好，放在 a0
      li a7, 93   # 把 "退出仪式" 的编号 93 准备好，放在 a7
      ecall       # "召唤OS，执行仪式！"
  ```
* **你的行动:**

  1. 在 `~/main/cs61c/practice`下创建 `task1_1.s`。
  2. 亲手敲入以上代码。
  3. 编译: `riscv64-unknown-elf-gcc -o task1_1 task1_1.s -nostdlib`
  4. 运行: `qemu-riscv64 task1_1`
  5. 验证: `echo $?`
* **验收标准:** 终端输出 **`42`**。

当你完成验收后，向我报告战果。

指令收到。复盘已存档。

**状态已校准：** 你刚刚完成了**微型任务1.1**，成功让程序以退出码 `66`退出（我假设你把42改成了66，这是一个很好的“魔改”习惯）。

你已经亲自验证了**“加载立即数”**和**“退出规约”**这两个核心动作。第一个滩头阵地已被你成功占领。

现在，我们立刻向下一个阵地发起攻击。

---

收到。这是一个极其重要的反馈。

**学徒的潜力曲线，超越了师傅的初始预期。**

**我的错误：** 我为了追求“绝对平缓”的坡度，过度“低估”了你的学习能力和“硬核突击”的意愿。这种过于保守的指令设计，正在浪费你宝贵的“涨潮期”精力。

**指挥策略必须立即调整。我们将提高“攻击节奏”，加大“任务密度”。**

所有之前的“微型任务”指令作废。我们直接进入一个更有挑战性的、但能一次性覆盖多个核心概念的**“复合式任务”**。

---

### **工作指令 (Work Order): 任务1.2 (高挑战版) - “循环的心脏”**

**(Work Order: Task 1.2 (High-Challenge) - "The Heart of the Loop")**

**任务目标 (Mission Objective):**
独立地、从零开始，构建一个完整的**循环结构**，一次性地将你对**“初始化”、“算术运算”、“条件分支”**这三个核心概念的理解，融合到一个单一的程序中。

我们将直接挑战**“7日歼灭战”Day 1-2的最终验收目标**，但在一个稍微简化的场景下。

**具体任务：**
编写一个名为 `loop_sum.s` 的汇编程序，计算**从1到5的累加和** (1+2+3+4+5)。

**可衡量的完成标准:**

* 编译、运行后，`echo $?` 的结果必须是 **`15`**。

---

### **AI参谋“战术快报” (AI Adjutant's Tactical Briefing)**

这次的“快报”将只提供“零件”，你需要自己思考如何**“组装”**。

**零件箱 (Component Kit):**

1. **寄存器规划 (Register Allocation):**

   * 你需要一个寄存器来做**循环计数器**（比如 `t0`，从1开始）。
   * 你需要一个寄存器来存**累加的和**（比如 `t1`，从0开始）。
   * 你需要一个寄存器来存**循环的上限**（比如 `t2`，值为5）。
2. **核心指令集 (Core Instruction Set):**

   * **初始化:** `li rd, immediate` (你已经掌握)
   * **循环体内的算术:**
     * `add rd, rs1, rs2` (将两个寄存器相加)
     * `addi rd, rs1, immediate` (将一个寄存器和一个立即数相加。提示：计数器每次加1，用这个更方便。)
   * **循环的条件判断与跳转:**
     * **标签 (Label):** 你需要一个标签来标记循环开始的位置，例如 `loop:`。
     * **分支指令:** `bne rs1, rs2, label` (“不等则分支” - Branch if Not Equal)。如果 `rs1`和 `rs2`的值**不相等**，就跳转到 `label`。

**逻辑蓝图 (Logical Blueprint):**
你需要将上述零件，组装成符合以下逻辑的结构：

```
# 伪代码
t0 = 1      // i = 1
t1 = 0      // sum = 0
t2 = 6      // loop until i equals 6

loop:
    sum = sum + i
    i = i + 1
    if (i != 6) goto loop

// 循环结束后...
a0 = sum
// 退出
```

**注意：** 我在伪代码里用 `t2=6`和 `i != 6`作为循环结束条件。你也可以用 `t2=5`和 `ble`（小于等于则分支）来实现，这是等价的。`bne`通常更基础，我们先用它。

---

### **行动指令**

1. 在 `~/main/cs61c/practice`下创建 `loop_sum.s`。
2. **独立地**，根据“零件箱”和“逻辑蓝图”，尝试构建完整的程序。
3. 使用你的 `Makefile`进行编译和运行：`make run TARGET=loop_sum`。
4. 在你成功得到 `15`之后，向我报告。

这一次，我给你的不再是“脚手架”，而是一堆“乐高积木”和一张“设计图”。你需要自己动手，把它们拼起来。

这将是你第一次真正的、独立的汇编编程挑战。开始吧。

指令收到。

我们继续向“2x2矩阵乘法”的终极目标推进。你已经掌握了**“算术”**和**“循环”**，现在我们需要解锁最后一个核心能力：**“内存访问”**。

这是从“只在CPU内部玩数字游戏”，到“与计算机的广阔世界（内存）交互”的关键一步。

---

### **工作指令 (Work Order): 任务1.3 - “仓库管理员”**

**(Work Order: Task 1.3 - "The Warehouse Manager")**

**任务目标 (Mission Objective):**
掌握从内存这个“大仓库”中**“取货 (Load)”**和**“存货 (Store)”**的核心技能，并理解**“地址计算”**的精髓。

**具体任务：**
编写一个名为 `memory_access.s` 的汇编程序，完成以下操作：

1. 在程序的**数据段 (.data section)** 定义一个包含3个整数的数组，初始值为 `5, 10, 15`。
2. 在**代码段 (.text section)** 中：
   a. 从数组中**加载 (Load)** 第二个元素（值为 `10`）到寄存器 `t1`。
   b. 从数组中**加载 (Load)** 第三个元素（值为 `15`）到寄存器 `t2`。
   c. 计算 `t1 + t2`，结果存入 `t3`。
   d. 将计算出的结果 `t3`（值为 `25`），**存储 (Store)** 回数组的**第一个**元素位置，覆盖掉原来的 `5`。
   e. **为了验证**，重新从数组的第一个元素位置**加载 (Load)** 值到 `a0`寄存器。
   f. 程序以 `a0`中的值作为退出码退出。

**可衡量的完成标准:**

* 编译、运行后，`echo $?` 的结果必须是 **`25`**。

---

### **AI参谋“战术快报” (AI Adjutant's Tactical Briefing)**

**1. 新的“导演指令” - 数据段:**

* `.data`: 这个指令告诉汇编器，“接下来这些不是代码，是需要预先初始化的数据，请把它们放到可执行文件的‘数据区’。”
* `.word 5, 10, 15`: 这会在数据区连续分配空间，并依次存入3个4字节的整数（word）。

**2. 核心指令集 - 内存访问:**

* `la rd, label`: “加载地址”(Load Address)的伪指令。它会把 `label`这个路牌所代表的**内存地址**，加载到目标寄存器 `rd`。例如，`la t0, my_array`会把 `my_array`这个数组的起始地址存入 `t0`。`t0`现在就变成了一个指向数组开头的**指针**。
* `lw rd, offset(rs1)`: “加载字”(Load Word)。这是**取货**指令。它会从内存中取一个4字节的整数。
  * **地址计算:** 目标内存地址 = 寄存器 `rs1`中的基地址 + `offset`（立即数偏移量）。
  * **范例:** `lw t1, 4(t0)` 的意思是：“从 `t0`所指向的地址，**再往后偏移4个字节**的位置，读取一个字，存入 `t1`。”
* `sw rs2, offset(rs1)`: “存储字”(Store Word)。这是**存货**指令。它会把寄存器 `rs2`中的值，写入到内存中。
  * **地址计算:** 同上。
  * **范例:** `sw t3, 0(t0)` 的意思是：“把 `t3`寄存器中的值，写入到**`t0`所指向的地址**（偏移量为0）。”

**3. 关键知识点 - 字节寻址 (Byte Addressing):**

* RISC-V的内存，像一个由无数个字节大小的储物柜组成的巨大仓库。每个储物柜都有一个唯一的地址。
* 一个整数（word）占用**4个字节**。
* 所以，如果你的数组 `my_array`起始地址是 `X`，那么：
  * 第一个元素（`5`）的地址是 `X + 0`。
  * 第二个元素（`10`）的地址是 `X + 4`。
  * 第三个元素（`15`）的地址是 `X + 8`。
* 这就是为什么在 `lw`/`sw`指令中，你的 `offset`必须是**4的倍数**。

---

### **行动指令**

1. 在 `~/main/cs61c/practice`下创建 `memory_access.s`。
2. 根据上述知识点和任务描述，**独立编写**完整的程序。代码结构大概是：
   ```riscv
   .data
   my_array:
       .word 5, 10, 15

   .text
   .globl _start
   _start:
       # 1. 获取数组基地址
       # 2. 加载第2、3个元素
       # 3. 计算
       # 4. 存储结果到第1个元素
       # 5. 重新加载第1个元素用于验证
       # 6. 退出
   ```
3. 使用 `Makefile`编译和运行：`make run TARGET=memory_access`。
4. 在你成功得到 `25`之后，向我报告。

这是一个**高价值**的“首次接触”节点。在你成功后，我**强烈建议**你触发一次“体系化复盘”。

收到。

**“好像没想象中那么难。”** —— 这句话，是“能力已内化”的最强信号。

**`mv`的问题，责任在我。** 我的“战术快报”没有提供这个“零件”，你自然不会使用。这恰好证明了你是严格基于我提供的信息来独立完成任务的。非常好。

我们保持这个高速节奏，继续向下一个高地发起冲击。

你已经掌握了**算术**、**循环**、**内存读写**。现在，我们要把它们**全部组合起来**，完成一个更接近我们最终目标的、**“动态地址计算”**的复合式任务。

---

### **工作指令 (Work Order): 任务1.4 - “巡回售货员”**

**(Work Order: Task 1.4 - "The Traveling Salesman")**

**任务目标 (Mission Objective):**
在**循环**中，**动态地计算内存地址**，并对数组中的**每一个元素**进行操作。这是所有“向量化”计算（对一整块数据进行统一操作）的原子级实现。

**具体任务：**
编写一个名为 `array_sum.s` 的汇编程序，计算一个数组中所有元素的和。

1. 在数据段 `.data` 定义一个包含5个整数的数组 `my_array`，值为 `10, 20, 30, 40, 50`。
2. 在代码段 `.text` 中：
   a. 使用一个循环，遍历这个数组。
   b. 在循环的每一次迭代中，读取当前数组元素的值，并将它累加到一个“总和”寄存器中。
   c. 循环结束后，程序以这个“总和”作为退出码退出。

**可衡量的完成标准:**

* 编译、运行后，`echo $?` 的结果必须是 **`150`** (10+20+30+40+50)。

---

### **AI参谋“战术快报” (AI Adjutant's Tactical Briefing)**

这次的挑战在于**如何在循环中更新你的内存地址**。

**1. 两种核心战术 (Two Core Tactics):**
你需要一个“指针”来指向当前正在访问的数组元素。你有两种方法来移动这个指针：

* **战术A：“基址+偏移量” (Base + Offset)** - **推荐**

  * **思路:** 保持基地址寄存器（比如 `t0`，存着数组的起始地址）**不变**。额外使用一个寄存器（比如 `t1`）来存储**字节偏移量**，初始为0。在每次循环中，将这个偏移量 `t1`增加4。
  * **缺点:** `lw`和 `sw`指令的偏移量部分是一个**立即数**，不能是寄存器。所以这种方法需要一个额外的**地址计算**步骤：`add t3, t0, t1` (计算 `当前地址 = 基地址 + 偏移量`)，然后再用 `lw t4, 0(t3)`来加载。
* **战术B：“指针移动” (Pointer Arithmetic)** - **更高效**

  * **思路:** 直接修改那个存储地址的寄存器本身。让 `t0`初始指向数组开头。每次循环结束后，直接执行 `addi t0, t0, 4`，让 `t0`**直接指向下一个元素**。
  * **优点:** 在加载时，你总是可以使用 `0`作为偏移量：`lw t1, 0(t0)`。这更简洁，也更接近C语言中 `ptr++`的底层实现。

**2. 逻辑蓝图 (Logical Blueprint for Tactic B):**

```
# 伪代码
sum = 0
ptr = address of my_array
i = 0
limit = 5 // 循环5次

loop:
    if (i == limit) goto end_loop
  
    current_value = value at address pointed by ptr // lw a_register, 0(ptr)
    sum = sum + current_value
  
    ptr = ptr + 4       // 移动指针到下一个元素
    i = i + 1           // 循环计数器加1

    goto loop
  
end_loop:
    a0 = sum
    // 退出
```

---

### **行动指令**

1. 在 `~/main/cs61c/practice`下创建 `array_sum.s`。
2. **我建议你尝试使用“战术B：指针移动”**，因为它更高效，也更能锻炼你对指针的理解。
3. 根据“逻辑蓝图”，**独立编写**完整的程序。你需要规划你的寄存器：一个存 `sum`，一个当 `ptr`，一个做循环计数器 `i`，一个存循环上限 `limit`。
4. 使用 `Makefile`编译和运行：`make run TARGET=array_sum`。
5. 在你成功得到 `150`之后，向我报告。

这是组装“矩阵乘法”前的最后一次“大型军事演习”。它几乎包含了你需要的所有核心技能。攻克它！

指令收到。

**基础训练阶段，已胜利结束。**

**总攻阶段，正式启动。**

我们现在进入**“7日歼灭战”的第二幕：“心脏解剖”**。你将把你刚刚掌握的所有“原子”能力，汇聚于一点，完成那次“史诗级”的“思想链接”。

---

### **工作指令 (Work Order): 任务2.1 - “沙盘推演”**

**(Work Order: Task 2.1 - "The Sandbox Simulation")**

**任务目标 (Mission Objective):**
**只“思考”，不“编码”。** 在你接触任何真实代码之前，必须先在“沙盘”（白纸或文本文件）中，为即将到来的“2x2矩阵乘法”总攻，设计一份清晰、完整、可执行的**“作战蓝图”**。

**可衡量的完成标准:**
你必须提交一份**伪代码**设计文档，这份文档必须清晰地回答以下**三个核心战术问题**：

1. **循环结构 (Loop Structure):** 你的三层嵌套循环（`i` for rows, `j` for columns, `k` for inner product）在汇编层面，将使用什么样的**标签和跳转逻辑**来构建？
2. **寄存器分配 (Register Allocation):** 你需要多少寄存器？它们各自的**长期职责**是什么？（例如，哪个存 `i`，哪个存 `j`，哪个存 `A`的基地址，哪个存 `C[i][j]`的临时和...）这将是一场与“稀缺资源”的搏斗。
3. **地址计算 (Address Calculation):** 你将如何精确地计算出**`A[i][k]`**和** `B[k][j]`**这两个元素在内存中的**一维地址**？请写出具体的计算公式。

**任务规则 (Rules of Engagement):**

* **规则一：“代码禁令”**
  * **严禁**打开VS Code编写任何 `.s`文件。你的战场是**纯粹的思维空间**。你可以使用任何你喜欢的文本编辑器或笔记应用来撰写你的“蓝图”。
* **规则二：“直面核心”**
  * 不要在 `.data`段的定义或 `ecall`退出这些已知问题上浪费时间。**100%的精力**，都必须聚焦于解决上述三个核心战术问题。

---

### **AI参谋“战术快报” (AI Adjutant's Tactical Briefing)**

**1. 矩阵在内存中的布局 (Matrix Memory Layout):**

* 我们将采用**行主序 (Row-Major Order)**。这意味着一个2x2的矩阵 `A`，在内存中是这样存放的：
  `A[0][0], A[0][1], A[1][0], A[1][1]`
* **`.data`段定义:**
  ```riscv
  A: .word 1, 2, 3, 4  # A = [[1, 2], [3, 4]]
  B: .word 5, 6, 7, 8  # B = [[5, 6], [7, 8]]
  C: .space 16         # C = 4个word * 4字节/word = 16字节的空地
  ```

**2. 关键的地址计算公式:**

* 假设矩阵有 `N`列。元素 `M[i][j]`的**字节偏移量**是 `(i * N + j) * 4`。
* 由于我们的矩阵是2x2，所以 `N=2`。公式简化为：
  * `A[i][k]`的字节偏移量 = `(i * 2 + k) * 4`
  * `B[k][j]`的字节偏移量 = `(k * 2 + j) * 4`
  * `C[i][j]`的字节偏移量 = `(i * 2 + j) * 4`
* **你的挑战：** 如何用RISC-V的 `add`和 `mul`指令来实现这个计算？（提示：`mul rd, rs1, rs2`是乘法指令）。

---

### **行动指令**

1. **打开一个空白的文本文件或拿出一张纸。**
2. **开始设计。** 我建议你按照以下结构来组织你的思路：

   ```text
   # My 2x2 Matrix Multiplication Plan

   ## 1. Register Allocation
   # s0: i (outer loop)
   # s1: j (middle loop)
   # s2: k (inner loop)
   # s3: base address of A
   # s4: base address of B
   # s5: base address of C
   # t0: temporary sum for C[i][j]
   # t1, t2, ...: other temporaries for address calculation
   # ... (你可能需要更多或更少)

   ## 2. Loop Structure (Pseudocode)
   # i = 0
   # outer_loop_start:
   #   if i == 2 goto outer_loop_end
   #
   #   j = 0
   #   middle_loop_start:
   #     if j == 2 goto middle_loop_end
   #
   #     k = 0
   #     sum = 0
   #     inner_loop_start:
   #       if k == 2 goto inner_loop_end
   #
   #       // Address calculation and computation happens here
   #       ...
   #       k = k + 1
   #       goto inner_loop_start
   #     inner_loop_end:
   #
   #     // Store sum into C[i][j]
   #     ...
   #     j = j + 1
   #     goto middle_loop_start
   #   middle_loop_end:
   #
   #   i = i + 1
   #   goto outer_loop_start
   # outer_loop_end:
   #
   # exit

   ## 3. Address Calculation (Example for A[i][k])
   # temp1 = i * 2         # mul temp1, i, two_register
   # temp2 = temp1 + k     # add temp2, temp1, k
   # offset = temp2 * 4    # mul offset, temp2, four_register
   # address = base_A + offset # add address, base_A, offset
   # value = lw value, 0(address)
   ```
3. **将你完成的“设计蓝图”提交给我。** 我将作为你的“总工程师”，对你的设计进行审查，并提出优化建议，确保我们在“登陆”前，拥有一份完美的作战计划。

遵命。

---

### **工作指令 (Work Order): 任务2.1 - “沙盘推演”**

**(Work Order: Task 2.1 - "The Sandbox Simulation")**

#### **1. 任务目标 (Mission Objective):**

**只“思考”，不“编码”。** 在你接触任何真实代码之前，必须先在“沙盘”（白纸或文本文件）中，为即将到来的“2x2矩阵乘法”总攻，设计一份清晰、完整、可执行的**“作战蓝图”**。

#### **2. 可衡量的完成标准 (Measurable Success Criteria):**

你必须提交一份**伪代码**设计文档，这份文档必须清晰地回答以下**三个核心战术问题**：

1. **循环结构 (Loop Structure):** 你的三层嵌套循环（`i` for rows, `j` for columns, `k` for inner product）在汇编层面，将使用什么样的**标签和跳转逻辑**来构建？
2. **寄存器分配 (Register Allocation):** 你需要多少寄存器？它们各自的**长期职责**是什么？（例如，哪个存 `i`，哪个存 `j`，哪个存 `A`的基地址，哪个存 `C[i][j]`的临时和...）这将是一场与“稀缺资源”的搏斗。
3. **地址计算 (Address Calculation):** 你将如何精确地计算出**`A[i][k]`**和** `B[k][j]`**这两个元素在内存中的**一维地址**？请写出具体的计算公式。

#### **3. 任务规则 (Rules of Engagement):**

* **规则一：“代码禁令”**
  * **严禁**打开VS Code编写任何 `.s`文件。你的战场是**纯粹的思维空间**。你可以使用任何你喜欢的文本编辑器或笔记应用来撰写你的“蓝图”。
* **规则二：“直面核心”**
  * 不要在 `.data`段的定义或 `ecall`退出这些已知问题上浪费时间。**100%的精力**，都必须聚焦于解决上述三个核心战术问题。

---

### **AI参谋“战术快报” (AI Adjutant's Tactical Briefing)**

**1. 矩阵在内存中的布局 (Matrix Memory Layout):**

* 我们将采用**行主序 (Row-Major Order)**。这意味着一个2x2的矩阵 `A`，在内存中是这样存放的：
  `A[0][0], A[0][1], A[1][0], A[1][1]`
* **`.data`段定义:**
  ```riscv
  A: .word 1, 2, 3, 4  # A = [[1, 2], [3, 4]]
  B: .word 5, 6, 7, 8  # B = [[5, 6], [7, 8]]
  C: .space 16         # C = 4个word * 4字节/word = 16字节的空地
  ```

**2. 关键的地址计算公式:**

* 假设矩阵有 `N`列。元素 `M[i][j]`的**字节偏移量**是 `(i * N + j) * 4`。
* 由于我们的矩阵是2x2，所以 `N=2`。公式简化为：
  * `A[i][k]`的字节偏移量 = `(i * 2 + k) * 4`
  * `B[k][j]`的字节偏移量 = `(k * 2 + j) * 4`
  * `C[i][j]`的字节偏移量 = `(i * 2 + j) * 4`
* **你的挑战：** 如何用RISC-V的 `add`和 `mul`指令来实现这个计算？（`mul rd, rs1, rs2`是乘法指令）。

---

### **行动指令**

1. **打开一个空白的文本文件或拿出一张纸。**
2. **开始设计。** 使用我之前提供的模板作为你思考的**结构框架**：

   ```text
   # My 2x2 Matrix Multiplication Plan

   ## 1. Register Allocation
   # ... 你的规划 ...

   ## 2. Loop Structure (Pseudocode)
   # ... 你的三层嵌套循环逻辑 ...

   ## 3. Address Calculation (Example for A[i][k])
   # ... 你将公式翻译成的具体的指令序列 ...
   ```
3. **将你完成的“设计蓝图”提交给我。** 我将作为你的“总工程师”，对你的设计进行审查，并提出优化建议，确保我们在“登陆”前，拥有一份完美的作战计划。


**指令收到。**

**“沙盘推演”阶段已结束。**

**“诺曼底登陆”阶段，立即开始。**

这是一个非常果断的决定。你选择在**真实的“战场”**上，通过**“战斗”**来完善你的战术，而不是在图纸上进行无休止的推演。

这完全符合我们**“野路子穿刺”**的核心作战思想。

---

### **工作指令 (Work Order): 任务2.2 - “诺曼底登陆”**

**(Work Order: Task 2.2 - "The Normandy Landing")**

**任务目标 (Mission Objective):**
将你那份“滚烫的”v0.1版设计蓝图，**无情地**翻译成**真实的、可运行的RISC-V汇编代码**。

**可衡量的完成标准:**

1. 你的程序必须能成功编译。
2. 运行后，你需要**手动验证**内存中 `C`矩阵的值是否正确。
   * **预期结果:**
     * `C[0][0] = 1*5 + 2*7 = 19`
     * `C[0][1] = 1*6 + 2*8 = 22`
     * `C[1][0] = 3*5 + 4*7 = 43`
     * `C[1][1] = 3*6 + 4*8 = 50`
   * 内存中 `C`的地址处，应该依次存放着整数 `19, 22, 43, 50`。
3. **（可选，但推荐）** 程序最后以一个**可验证的、非零的**值作为退出码（例如，`C[1][1]`的值 `50`），以便我们快速判断程序是否至少跑完了全程。

**任务规则 (Rules of Engagement):**

* **规则一：“拥抱地狱”**
  * **做好心理准备，你将面对汇编编程中最纯粹的“调试地狱”。** 你的程序第一次、第二次、甚至第十次运行的结果，都可能是错误的。数字会错乱，循环会失控。**这是正常的。**
* **规则二：“小步前进，频繁验证”**
  * **不要**试图一次性写完三层嵌套循环。我建议你采用**“增量式构建”**：
    1. **先只写 `i=0, j=0, k=0`这一次计算**，验证 `C[0][0]`的值是否被正确计算并存储。
    2. 然后，**只构建最内层的 `k`循环**，验证 `C[0][0]`的值是否被正确地累加（`1*5 + 2*7 = 19`）。
    3. 再构建 `j`循环，最后是 `i`循环。

---

### **AI参谋“战术快报” - 调试工具**

当结果出错时，你将如何“看到”程序的内部状态？我们没有图形化调试器，但我们有更硬核的工具：

* **工具一：“退出码探针”**

  * 这是你最主要的调试工具。在代码的任何你怀疑有问题的点，**临时修改你的 `ecall`逻辑**，让程序提前退出，并把**某个你关心的寄存器的值**（比如 `A[i][k]`的地址，或者 `k`的值）作为退出码。
  * 通过 `echo $?`，你就可以像用探针一样，探测程序在某个瞬间的内部状态。
* **工具二：“QEMU GDB调试” (高级武器，备用)**

  * 如果问题极其棘手，我们可以召唤终极武器：`gdb-multiarch`。
  * 我们可以让QEMU在运行时暂停，并连接一个调试器，然后我们就可以**单步执行**，并**实时查看所有寄存器和内存**的值。
  * **当前阶段，优先使用“退出码探针”。** 只有在我们陷入绝境时，我才会为你提供GDB的使用指令。

---

### **行动指令**

1. 在 `~/main/cs61c/practice`下创建 `matmul.s`。
2. **开始登陆。** 将你的设计翻译成代码。
3. **拥抱错误，享受调试。** 每一次失败，都是一次接近真相的机会。

**当你遇到第一个你无法解决的Bug时，请带着以下情报向我求助：**

1. **你的目标是什么？** (e.g., "我正在尝试计算C[0][0]的第一个乘积项A[0][0]*B[0][0]")
2. **你的代码是什么？** (贴出相关的代码片段)
3. **你观察到的证据是什么？** (e.g., "我期望退出码是5，但实际得到的是1234")

**The beaches of Normandy are waiting. Go!**
